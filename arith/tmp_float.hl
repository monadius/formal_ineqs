needs "arith/more_float.hl";;
needs "update_database.ml";;

let exe = e;;

open Arith_nat;;
open Interval_arith;;
open Float_theory;;
open Arith_float;;
open Misc_functions;;
open Misc_vars;;

let FLOAT_0 = prove(`!s e. float_num s 0 e = &0`, REWRITE_TAC[FLOAT_EQ_0]);;


let FLOAT_ABS = prove(`abs (float_num s n e) = float_num F n e`,
   BOOL_CASES_TAC `s:bool` THEN
     REWRITE_TAC[FLOAT_NEG_T; REAL_ABS_NEG; REAL_ABS_REFL; FLOAT_F_POS]);;


let FLOAT_INTERVAL_FT_IMP_0 = prove(`interval_arith x (float_num F n1 e1, float_num T n2 e2) ==> x = &0`,
				    REWRITE_TAC[interval_arith] THEN STRIP_TAC THEN
				      REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
				      CONJ_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THENL [
					EXISTS_TAC `float_num T n2 e2` THEN ASM_REWRITE_TAC[FLOAT_T_NEG];
					EXISTS_TAC `float_num F n1 e1` THEN ASM_REWRITE_TAC[FLOAT_F_POS]
				      ]);;


let mk_test p_tm =
  let tm = mk_comb (`interval_arith x`, p_tm) in
    REWRITE_RULE[FLOAT_NEG] (More_float.RULE (ASSUME tm));;

let i1 = mk_test `&1, &2`;;
let i2 = mk_test `-- &1, &2`;;
let i3 = mk_test `-- &3, -- &1`;;
let i4 = mk_test `&0, &1`;;
let i5 = mk_test `-- &2, &1`;;

let f1, f2 = More_float.one_float, More_float.two_float;;
let f3 = More_float.mk_float_small 3 and
    f4 = More_float.mk_float_small 4;;



let mk_float =
  let float_const = `float_num` in
    fun s n_tm e_tm ->
      let s_tm = if s = "T" then t_const else f_const in
	mk_comb (mk_comb (mk_comb (float_const, s_tm), n_tm), e_tm);;


(* ------------------------------------------------ *)
(* Absolute value of an interval                    *)
(* ------------------------------------------------ *)

let RULE = UNDISCH_ALL o NUMERALS_TO_NUM o PURE_REWRITE_RULE[GSYM IMP_IMP; min_exp_def];;

let float_interval_abs_ft = (RULE o prove)
  (`interval_arith x (float_num F n1 e1, float_num T n2 e2)
     ==> interval_arith (abs x) (float_num F 0 min_exp, float_num F 0 min_exp)`,
   DISCH_THEN (MP_TAC o MATCH_MP FLOAT_INTERVAL_FT_IMP_0) THEN
     REWRITE_TAC[FLOAT_0; interval_arith] THEN REAL_ARITH_TAC);;

let float_interval_abs_ff = (RULE o prove)
  (`interval_arith x (float_num F n1 e1, float_num F n2 e2)
     ==> interval_arith (abs x) (float_num F n1 e1, float_num F n2 e2)`,
   MP_TAC (SPECL[`n1:num`; `e1:num`] FLOAT_F_POS) THEN 
     REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;

let float_interval_abs_tt = (RULE o prove)
  (`interval_arith x (float_num T n1 e1, float_num T n2 e2)
     ==> interval_arith (abs x) (float_num F n2 e2, float_num F n1 e1)`,
   MP_TAC ((GSYM o SPEC `T`) FLOAT_NEG) THEN SIMP_TAC[] THEN DISCH_TAC THEN
     MP_TAC (SPECL[`n2:num`; `e2:num`] FLOAT_T_NEG) THEN
     REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;

let float_interval_abs_tf = (RULE o prove)
  (`interval_arith x (float_num T n1 e1, float_num F n2 e2) /\
     max (float_num F n1 e1) (float_num F n2 e2) = t
      ==> interval_arith (abs x) (float_num F 0 min_exp, t)`,
   MP_TAC ((GSYM o SPEC `F`) FLOAT_NEG) THEN SIMP_TAC[] THEN DISCH_TAC THEN
     REWRITE_TAC[interval_arith; FLOAT_0] THEN REAL_ARITH_TAC);;

let float_interval_abs th =
  let x, lo, hi = dest_float_interval (concl th) in
  let s1, n1, e1 = dest_float lo and
      s2, n2, e2 = dest_float hi in
  let inst = INST[x, x_var_real; 
		  n1, n1_var_num; e1, e1_var_num;
		  n2, n2_var_num; e2, e2_var_num] in
    if s1 = s2 then
      if s1 = "F" then
	(* FF *)
	MY_PROVE_HYP th (inst float_interval_abs_ff)
      else
	(* TT *)
	MY_PROVE_HYP th (inst float_interval_abs_tt)
    else
      if s1 = "F" then
	(* FT *)
	MY_PROVE_HYP th (inst float_interval_abs_ft)
      else
	let max_th = float_max (mk_float "F" n1 e1) hi in
	let t_tm = rand (concl max_th) in
	let th0 = INST[x, x_var_real; t_tm, t_var_real;
		       n1, n1_var_num; e1, e1_var_num;
		       n2, n2_var_num; e2, e2_var_num] float_interval_abs_tf in
	  MY_PROVE_HYP max_th (MY_PROVE_HYP th th0);;

(* ------------------------------------------------ *)
(* Power of a float                                 *)
(* ------------------------------------------------ *)

let eval_suc i_tm =
  raw_suc_conv_hash (mk_comb (suc_op_num, i_tm));;

let eval_mul a b =
  raw_mul_conv_hash (mk_comb (mk_comb (mul_op_num, a), b));;

let eval_even =
  let even_const = `EVEN` in
    fun n_tm ->
      raw_even_hash_conv (mk_comb (even_const, n_tm));;

let float_pow_pos_suc_hi_th = (RULE o prove)
  (`float_num F n e pow j <= t /\ float_num F n e * t <= hi /\  SUC j = i
     ==> float_num F n e pow i <= hi`,
   STRIP_TAC THEN (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REWRITE_TAC[real_pow] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `float_num F n e * t` THEN ASM_REWRITE_TAC[] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[FLOAT_F_POS; REAL_LE_REFL] THEN
     MATCH_MP_TAC REAL_POW_LE THEN REWRITE_TAC[FLOAT_F_POS]);;

let float_pow_pos_double_hi_th = (RULE o prove)
  (`float_num F n e pow j <= t /\ t * t <= hi /\ 2 * j = i
       ==> float_num F n e pow i <= hi`,
   STRIP_TAC THEN (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     ONCE_REWRITE_TAC[MULT_SYM] THEN REWRITE_TAC[GSYM REAL_POW_POW; REAL_POW_2] THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `t * t:real` THEN ASM_REWRITE_TAC[] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[FLOAT_F_POS; REAL_LE_REFL] THEN
     MATCH_MP_TAC REAL_POW_LE THEN REWRITE_TAC[FLOAT_F_POS]);;

let float_pow0_hi = (RULE o REWRITE_RULE[SYM More_float.float1_eq] o prove)
  (`x pow 0 <= &1`, 
   REWRITE_TAC[real_pow; REAL_LE_REFL]);;

let float_pow1_hi = (RULE o prove)
  (`x pow 1 <= x`, 
   REWRITE_TAC[REAL_POW_1; REAL_LE_REFL]);;

let float_pow2_hi = (RULE o prove)
  (`x * x <= hi ==> x pow 2 <= hi`, 
   REWRITE_TAC[REAL_POW_2]);;

let float_pow_pos_suc_lo_th = (RULE o prove)
  (`float_num F n1 e1 <= float_num F n e pow j /\ 
     lo <= float_num F n e * float_num F n1 e1 /\  SUC j = i
     ==> lo <= float_num F n e pow i`,
   STRIP_TAC THEN (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REWRITE_TAC[real_pow] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `float_num F n e * float_num F n1 e1` THEN ASM_REWRITE_TAC[] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[FLOAT_F_POS; REAL_LE_REFL]);;

let float_pow_pos_double_lo_th = (RULE o prove)
  (`float_num F n1 e1 <= x pow j /\ lo <= float_num F n1 e1 * float_num F n1 e1 /\ 2 * j = i
       ==> lo <= x pow i`,
   STRIP_TAC THEN (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     ONCE_REWRITE_TAC[MULT_SYM] THEN REWRITE_TAC[GSYM REAL_POW_POW] THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `float_num F n1 e1 pow 2` THEN
     ASM_REWRITE_TAC[REAL_POW_2] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[FLOAT_F_POS; REAL_LE_REFL]);;

let float_pow0_lo = (RULE o REWRITE_RULE[SYM More_float.float1_eq] o prove)
  (`&1 <= x pow 0`, 
   REWRITE_TAC[real_pow; REAL_LE_REFL]);;

let float_pow1_lo = (RULE o prove)
  (`x <= x pow 1`, 
   REWRITE_TAC[REAL_POW_1; REAL_LE_REFL]);;

let float_pow2_lo = (RULE o prove)
  (`lo <= x * x ==> lo <= x pow 2`, 
   REWRITE_TAC[REAL_POW_2]);;

let float_pow_neg_even_hi_th = (RULE o prove)
  (`(EVEN i <=> T) /\ float_num F n e pow i <= hi
     ==> float_num T n e pow i <= hi`,
   STRIP_TAC THEN
     SUBGOAL_THEN `float_num T n e pow i = float_num F n e pow i` ASSUME_TAC THENL [
       ASM_REWRITE_TAC[REAL_POW_EQ_EQ; FLOAT_ABS];
       ALL_TAC
     ] THEN
     ASM_REWRITE_TAC[]);;

let float_pow_neg_even_lo_th = (RULE o prove)
  (`(EVEN i <=> T) /\ lo <= float_num F n e pow i
     ==> lo <= float_num T n e pow i`,
   STRIP_TAC THEN
     SUBGOAL_THEN `float_num T n e pow i = float_num F n e pow i` ASSUME_TAC THENL [
       ASM_REWRITE_TAC[REAL_POW_EQ_EQ; FLOAT_ABS];
       ALL_TAC
     ] THEN
     ASM_REWRITE_TAC[]);;

let float_pow_neg_odd_hi_th = (RULE o prove)
  (`(EVEN i <=> F) /\ float_num F n1 e1 <= float_num F n e pow i
     ==> float_num T n e pow i <= float_num T n1 e1`,
   MP_TAC ((GSYM o SPEC `F`) FLOAT_NEG) THEN SIMP_TAC[] THEN REPEAT STRIP_TAC THEN
     ASM_REWRITE_TAC[REAL_POW_NEG; REAL_LE_NEG]);;

let float_pow_neg_odd_lo_th = (RULE o prove)
  (`(EVEN i <=> F) /\ float_num F n e pow i <= float_num F n1 e1
     ==> float_num T n1 e1 <= float_num T n e pow i`,
   MP_TAC ((GSYM o SPEC `F`) FLOAT_NEG) THEN SIMP_TAC[] THEN REPEAT STRIP_TAC THEN
     ASM_REWRITE_TAC[REAL_POW_NEG; REAL_LE_NEG]);;


let float_pow_pos_suc_hi pp x_tm t_th =
  let _, n_tm, e_tm = dest_float x_tm in
  let ltm, t_tm = dest_comb (concl t_th) in
  let j_tm = rand (rand ltm) in
  let suc_j = eval_suc j_tm in
  let i_tm = rand (concl suc_j) in
  let mul_hi = float_mul_hi pp x_tm t_tm in
  let hi_tm = rand (concl mul_hi) in
  let th0 = INST[n_tm, n_var_num; e_tm, e_var_num; j_tm, j_var_num;
		 t_tm, t_var_real; hi_tm, hi_var_real;
		 i_tm, i_var_num] float_pow_pos_suc_hi_th in
    MY_PROVE_HYP t_th (MY_PROVE_HYP mul_hi (MY_PROVE_HYP suc_j th0));;

let float_pow_pos_suc_lo pp x_tm t_th =
  let _, n_tm, e_tm = dest_float x_tm in
  let ltm, rtm = dest_comb (concl t_th) in
  let t_tm = rand ltm in
  let j_tm = rand rtm in
  let _, n1_tm, e1_tm = dest_float t_tm in
  let suc_j = eval_suc j_tm in
  let i_tm = rand (concl suc_j) in
  let mul_lo = float_mul_lo pp x_tm t_tm in
  let lo_tm = lhand (concl mul_lo) in
  let th0 = INST[n_tm, n_var_num; e_tm, e_var_num; j_tm, j_var_num;
		 n1_tm, n1_var_num; e1_tm, e1_var_num; lo_tm, lo_var_real;
		 i_tm, i_var_num] float_pow_pos_suc_lo_th in
    MY_PROVE_HYP t_th (MY_PROVE_HYP mul_lo (MY_PROVE_HYP suc_j th0));;

let float_pow_pos_double_hi =
  let raw2 = rand (mk_small_numeral_array 2) in
    fun pp x_tm t_th ->
      let _, n_tm, e_tm = dest_float x_tm in
      let ltm, t_tm = dest_comb (concl t_th) in
      let j_tm = rand (rand ltm) in
      let double_j = eval_mul raw2 j_tm in
      let i_tm = rand (concl double_j) in
      let mul_hi = float_mul_hi pp t_tm t_tm in
      let hi_tm = rand (concl mul_hi) in
      let th0 = INST[n_tm, n_var_num; e_tm, e_var_num; j_tm, j_var_num;
		     t_tm, t_var_real; hi_tm, hi_var_real;
		     i_tm, i_var_num] float_pow_pos_double_hi_th in
	MY_PROVE_HYP t_th (MY_PROVE_HYP mul_hi (MY_PROVE_HYP double_j th0));;

let float_pow_pos_double_lo =
  let raw2 = rand (mk_small_numeral_array 2) in
    fun pp x_tm t_th ->
      let ltm, rtm = dest_comb (concl t_th) in
      let t_tm = rand ltm in
      let j_tm = rand rtm in
      let _, n1_tm, e1_tm = dest_float t_tm in
      let double_j = eval_mul raw2 j_tm in
      let i_tm = rand (concl double_j) in
      let mul_lo = float_mul_lo pp t_tm t_tm in
      let lo_tm = lhand (concl mul_lo) in
      let th0 = INST[x_tm, x_var_real; n1_tm, n1_var_num; e1_tm, e1_var_num; 
		     j_tm, j_var_num; lo_tm, lo_var_real;
		     i_tm, i_var_num] float_pow_pos_double_lo_th in
	MY_PROVE_HYP t_th (MY_PROVE_HYP mul_lo (MY_PROVE_HYP double_j th0));;

let float_pow_pos_hi pp x_tm n =
  let rec pow n =
    match n with
      | 0 -> INST[x_tm, x_var_real] float_pow0_hi
      | 1 -> INST[x_tm, x_var_real] float_pow1_hi
      | 2 ->
	  let mul_hi = float_mul_hi pp x_tm x_tm in
	  let hi_tm = rand (concl mul_hi) in
	  let th0 = INST[x_tm, x_var_real; hi_tm, hi_var_real] float_pow2_hi in
	    MY_PROVE_HYP mul_hi th0
     | _ ->
	  let _ = assert (n > 2) in
	  if (n land 1) = 0 then
	    (* even *)
	    let t_th = pow (n lsr 1) in
	      float_pow_pos_double_hi pp x_tm t_th
	  else
	    (* odd *)
	    let t_th = pow (n - 1) in
	      float_pow_pos_suc_hi pp x_tm t_th
  in
    pow n;;

let float_pow_pos_lo pp x_tm n =
  let rec pow n =
    match n with
      | 0 -> INST[x_tm, x_var_real] float_pow0_lo
      | 1 -> INST[x_tm, x_var_real] float_pow1_lo
      | 2 ->
	  let mul_lo = float_mul_lo pp x_tm x_tm in
	  let lo_tm = lhand (concl mul_lo) in
	  let th0 = INST[x_tm, x_var_real; lo_tm, lo_var_real] float_pow2_lo in
	    MY_PROVE_HYP mul_lo th0
     | _ ->
	  let _ = assert (n > 2) in
	  if (n land 1) = 0 then
	    (* even *)
	    let t_th = pow (n lsr 1) in
	      float_pow_pos_double_lo pp x_tm t_th
	  else
	    (* odd *)
	    let t_th = pow (n - 1) in
	      float_pow_pos_suc_lo pp x_tm t_th
  in
    pow n;;

let float_pow_hi0 pp x_tm (n_tm, n, n_even_opt) =
  match n with
    | 0 -> INST[x_tm, x_var_real] float_pow0_hi
    | 1 -> INST[x_tm, x_var_real] float_pow1_hi
    | 2 ->
	let mul_hi = float_mul_hi pp x_tm x_tm in
	let hi_tm = rand (concl mul_hi) in
	let th0 = INST[x_tm, x_var_real; hi_tm, hi_var_real] float_pow2_hi in
	  MY_PROVE_HYP mul_hi th0
    | _ ->
	let s, xn_tm, e_tm = dest_float x_tm in
	  if s = "F" then
	    float_pow_pos_hi pp x_tm n
	  else
	    let x_pos = mk_float "F" xn_tm e_tm in
	    let n_even = 
	      (match n_even_opt with
		 | None -> eval_even n_tm
		 | Some th -> th) in
	      if fst (dest_const (rand (concl n_even))) = "T" then
		let hi_th = float_pow_pos_hi pp x_pos n in
		let hi_tm = rand (concl hi_th) in
		let th0 = INST[xn_tm, n_var_num; e_tm, e_var_num; n_tm, i_var_num;
			       hi_tm, hi_var_real] float_pow_neg_even_hi_th in
		  MY_PROVE_HYP n_even (MY_PROVE_HYP hi_th th0)
	      else
		let lo_th = float_pow_pos_lo pp x_pos n in
		let lo_tm = lhand (concl lo_th) in
		let _, n1_tm, e1_tm = dest_float lo_tm in
		let th0 = INST[xn_tm, n_var_num; e_tm, e_var_num; n_tm, i_var_num;
			       n1_tm, n1_var_num; e1_tm, e1_var_num] float_pow_neg_odd_hi_th in
		  MY_PROVE_HYP n_even (MY_PROVE_HYP lo_th th0);;

let float_pow_hi pp x_tm n_tm =
  let n = Num.int_of_num (raw_dest_hash n_tm) in
    float_pow_hi0 pp x_tm (n_tm, n, None);;

let float_pow_lo0 pp x_tm (n_tm, n, n_even_opt) =
  match n with
    | 0 -> INST[x_tm, x_var_real] float_pow0_lo
    | 1 -> INST[x_tm, x_var_real] float_pow1_lo
    | 2 ->
	let mul_lo = float_mul_lo pp x_tm x_tm in
	let lo_tm = lhand (concl mul_lo) in
	let th0 = INST[x_tm, x_var_real; lo_tm, lo_var_real] float_pow2_lo in
	  MY_PROVE_HYP mul_lo th0
    | _ ->
	let s, xn_tm, e_tm = dest_float x_tm in
	  if s = "F" then
	    float_pow_pos_lo pp x_tm n
	  else
	    let x_pos = mk_float "F" xn_tm e_tm in
	    let n_even = 
	      (match n_even_opt with
		 | None -> eval_even n_tm
		 | Some th -> th) in
	      if fst (dest_const (rand (concl n_even))) = "T" then
		let lo_th = float_pow_pos_lo pp x_pos n in
		let lo_tm = lhand (concl lo_th) in
		let th0 = INST[xn_tm, n_var_num; e_tm, e_var_num; n_tm, i_var_num;
			       lo_tm, lo_var_real] float_pow_neg_even_lo_th in
		  MY_PROVE_HYP n_even (MY_PROVE_HYP lo_th th0)
	      else
		let hi_th = float_pow_pos_hi pp x_pos n in
		let hi_tm = rand (concl hi_th) in
		let _, n1_tm, e1_tm = dest_float hi_tm in
		let th0 = INST[xn_tm, n_var_num; e_tm, e_var_num; n_tm, i_var_num;
			       n1_tm, n1_var_num; e1_tm, e1_var_num] float_pow_neg_odd_lo_th in
		  MY_PROVE_HYP n_even (MY_PROVE_HYP hi_th th0);;

let float_pow_lo pp x_tm n_tm =
  let n = Num.int_of_num (raw_dest_hash n_tm) in
    float_pow_lo0 pp x_tm (n_tm, n, None);;



(* ------------------------------------------------ *)
(* Power of an interval                             *)
(* ------------------------------------------------ *)

let float_interval_pow0 = (RULE o PURE_REWRITE_RULE[GSYM More_float.float1_eq] o 
			     prove)
  (`interval_arith (x pow 0) (&1, &1)`,
   REWRITE_TAC[real_pow; interval_arith; REAL_LE_REFL]);;

let float_interval_pow1 = (RULE o prove)
  (`interval_arith x (lo, hi) ==>
     interval_arith (x pow 1) (lo, hi)`,
   REWRITE_TAC[REAL_POW_1; interval_arith]);;

let float_interval_pow_ft = (RULE o prove)
  (`(n = 0 <=> F) /\ interval_arith x (float_num F n1 e1, float_num T n2 e2)
     ==> interval_arith (x pow n) (float_num F 0 min_exp, float_num F 0 min_exp)`,
   STRIP_TAC THEN
     POP_ASSUM (ASSUME_TAC o MATCH_MP FLOAT_INTERVAL_FT_IMP_0) THEN
     ASM_REWRITE_TAC[REAL_POW_ZERO; FLOAT_0; interval_arith; REAL_LE_REFL]);;

let float_interval_pow_odd = (RULE o prove)
  (`interval_arith x (low, high) /\
     (EVEN n <=> F) /\
     high pow n <= hi /\
     lo <= low pow n
     ==> interval_arith (x pow n) (lo, hi)`,
   REWRITE_TAC[NOT_EVEN; interval_arith] THEN STRIP_TAC THEN
     CONJ_TAC THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `low pow n` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_POW_LE2_ODD THEN ASM_REWRITE_TAC[];
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `high pow n` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_POW_LE2_ODD THEN ASM_REWRITE_TAC[]
     ]);;

let float_interval_pow_ff = (RULE o prove)
  (`interval_arith x (float_num F n1 e1, float_num F n2 e2) /\
     float_num F n2 e2 pow n <= hi /\
     lo <= float_num F n1 e1 pow n
     ==> interval_arith (x pow n) (lo, hi)`,
   REWRITE_TAC[interval_arith] THEN STRIP_TAC THEN
     CONJ_TAC THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `float_num F n1 e1 pow n` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_POW_LE2 THEN
	 ASM_REWRITE_TAC[FLOAT_F_POS];
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `float_num F n2 e2 pow n` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_POW_LE2 THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `float_num F n1 e1` THEN
	 ASM_REWRITE_TAC[FLOAT_F_POS]
     ]);;

let float_interval_pow_even_tt = (RULE o prove)
  (`interval_arith x (float_num T n1 e1, float_num T n2 e2) /\
     (EVEN n <=> T) /\
     float_num F n1 e1 pow n <= hi /\
     lo <= float_num F n2 e2 pow n
     ==> interval_arith (x pow n) (lo, hi)`,
   MP_TAC ((GSYM o SPEC `F`) FLOAT_NEG) THEN SIMP_TAC[] THEN DISCH_TAC THEN
     REWRITE_TAC[interval_arith] THEN STRIP_TAC THEN
     SUBGOAL_THEN `x pow n = (--x) pow n` (fun th -> REWRITE_TAC[th]) THENL [
       ASM_REWRITE_TAC[REAL_POW_NEG];
       ALL_TAC
     ] THEN
     CONJ_TAC THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `float_num F n2 e2 pow n` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_POW_LE2 THEN
	 ASM_REWRITE_TAC[FLOAT_F_POS; REAL_ARITH `a <= --b <=> b <= --a`];
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `float_num F n1 e1 pow n` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_POW_LE2 THEN
	 ONCE_REWRITE_TAC[REAL_ARITH `--x <= a <=> --a <= x`] THEN
	 ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `float_num F n2 e2` THEN
	 ASM_REWRITE_TAC[FLOAT_F_POS; REAL_ARITH `a <= --b <=> b <= --a`]
     ]);;

let float_interval_pow_even_tf = (RULE o prove)
  (`interval_arith x (float_num T n1 e1, float_num F n2 e2) /\
     (EVEN n <=> T) /\
     max (float_num F n1 e1) (float_num F n2 e2) = t /\
      t pow n <= hi
      ==> interval_arith (x pow n) (float_num F 0 min_exp, hi)`,
   MP_TAC ((GSYM o SPEC `F`) FLOAT_NEG) THEN SIMP_TAC[] THEN DISCH_TAC THEN
     REWRITE_TAC[interval_arith; EVEN_EXISTS] THEN STRIP_TAC THEN
     CONJ_TAC THENL [
       ASM_REWRITE_TAC[FLOAT_0] THEN
	 ONCE_REWRITE_TAC[MULT_SYM] THEN REWRITE_TAC[GSYM REAL_POW_POW] THEN
	 REWRITE_TAC[REAL_LE_POW_2];
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `t pow n` THEN ASM_REWRITE_TAC[] THEN
	 ONCE_REWRITE_TAC[MULT_SYM] THEN REWRITE_TAC[GSYM REAL_POW_POW] THEN
	 REWRITE_TAC[GSYM REAL_LE_SQUARE_ABS; REAL_ABS_POW] THEN
	 MATCH_MP_TAC REAL_POW_LE2 THEN REWRITE_TAC[REAL_ABS_POS] THEN
	 ASM_ARITH_TAC
     ]);;


let float_interval_pow pp x_th n_tm =
  let n = Num.int_of_num (raw_dest_hash n_tm) in
  let x, low, high = dest_float_interval (concl x_th) in
    match n with
      | 0 -> INST[x, x_var_real] float_interval_pow0
      | 1 -> 
	  let th0 = INST[x, x_var_real; low, lo_var_real; high, hi_var_real] float_interval_pow1 in
	    MY_PROVE_HYP x_th th0
      | _ ->
	  let _ = assert (n > 1) in
	  let even_n = eval_even n_tm in
	    if fst (dest_const (rand (concl even_n))) = "F" then
	      (* odd *)
	      let hi_th = float_pow_hi0 pp high (n_tm, n, Some even_n) and
		  lo_th = float_pow_lo0 pp low (n_tm, n, Some even_n) in
	      let hi = rand (concl hi_th) and
		  lo = lhand (concl lo_th) in
	      let th0 = INST[x, x_var_real; low, low_var_real; high, high_var_real;
			     hi, hi_var_real; lo, lo_var_real; n_tm, n_var_num] float_interval_pow_odd in
		MY_PROVE_HYP even_n (MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP x_th th0)))
	    else
	      (* even *)
	      let s1, n1, e1 = dest_float low and
		  s2, n2, e2 = dest_float high in
		if s1 = s2 then
		  if s1 = "F" then
		    (* FF *)
		    let hi_th = float_pow_hi0 pp high (n_tm, n, Some even_n) and
			lo_th = float_pow_lo0 pp low (n_tm, n, Some even_n) in
		    let hi = rand (concl hi_th) and
			lo = lhand (concl lo_th) in
		    let th0 = INST[x, x_var_real; n1, n1_var_num; e1, e1_var_num;
				   n2, n2_var_num; e2, e2_var_num; n_tm, n_var_num;
				   lo, lo_var_real; hi, hi_var_real] float_interval_pow_ff in
		      MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP x_th th0))
		  else
		    (* TT *)
		    let hi_th = float_pow_hi0 pp (mk_float "F" n1 e1) (n_tm, n, Some even_n) and
			lo_th = float_pow_lo0 pp (mk_float "F" n2 e2) (n_tm, n, Some even_n) in
		    let hi = rand (concl hi_th) and
			lo = lhand (concl lo_th) in
		    let th0 = INST[x, x_var_real; n1, n1_var_num; e1, e1_var_num;
				   n2, n2_var_num; e2, e2_var_num; n_tm, n_var_num;
				   lo, lo_var_real; hi, hi_var_real] float_interval_pow_even_tt in
		      MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP even_n (MY_PROVE_HYP x_th th0)))
		else
		  if s1 = "F" then
		    (* FT *)
		    let n0 = raw_eq0_hash_conv n_tm in
		      (* Should be n <> 0 *)
		    let th0 = INST[x, x_var_real; n_tm, n_var_num;
				   n1, n1_var_num; e1, e1_var_num;
				   n2, n2_var_num; e2, e2_var_num] float_interval_pow_ft in
		      MY_PROVE_HYP n0 (MY_PROVE_HYP x_th th0)
		  else
		    (* TF *)
		    let max_eq = float_max (mk_float "F" n1 e1) high in
		    let t_tm = rand (concl max_eq) in
		    let hi_th = float_pow_hi0 pp t_tm (n_tm, n, Some even_n) in
		    let hi = rand (concl hi_th) in
		    let th0 = INST[x, x_var_real; n_tm, n_var_num;
				   n1, n1_var_num; e1, e1_var_num;
				   n2, n2_var_num; e2, e2_var_num;
				   t_tm, t_var_real; hi, hi_var_real] float_interval_pow_even_tf in
		      MY_PROVE_HYP hi_th (MY_PROVE_HYP max_eq (MY_PROVE_HYP even_n (MY_PROVE_HYP x_th th0)));;


(*******************)	    

let n_tm = `(D5 _0)`;;
float_interval_pow 5 i1 n_tm;;
float_interval_pow 5 i2 n_tm;;
float_interval_pow 5 i3 n_tm;;
float_interval_pow 5 i4 n_tm;;
float_interval_pow 5 i5 n_tm;;

(********************)

let pp = 3;;
let x_tm = f2;;
let t_th = (RULE o REWRITE_RULE[SYM More_float.float2_eq; SYM More_float.float4_eq] o prove)
  (`&2 pow 2 <= &4`, REAL_ARITH_TAC);;
let t_th2 = (RULE o REWRITE_RULE[SYM More_float.float2_eq; SYM More_float.float4_eq] o prove)
  (`&4 <= &2 pow 2`, REAL_ARITH_TAC);;

let y_tm = (lhand o concl) (More_float.float_neg x_tm);;

float_pow_pos_hi 20 f2 `D1 (D0 (D1 _0))`;;
float_pow_pos_lo 20 f2 `D1 (D0 (D1 _0))`;;

test 1000 (float_pow_lo 10 f2) `D3 _0`;;
test 1000 (float_pow_lo 10 y_tm) `D3 _0`;;

float_pow_pos_double_hi pp x_tm t_th;;
float_pow_pos_suc_lo pp x_tm t_th2;;
float_pow_pos_double_lo pp x_tm t_th2;;

let x = 2;;


(*******************)

let float_pow_pos_suc_hi' = (RULE o prove)
  (`(&0 <= x <=> T) /\ x pow j <= t /\ x * t <= hi /\  SUC j = i
     ==> x pow i <= hi`,
   STRIP_TAC THEN (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REWRITE_TAC[real_pow] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `x * t` THEN ASM_REWRITE_TAC[] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[REAL_LE_REFL] THEN
     ASM_SIMP_TAC[REAL_POW_LE]);;

let test2 pp x_tm t_th =
  let x_ge0 = float_ge0 f1 in
    if fst (dest_const (rand (concl x_ge0))) <> "T" then
      failwith "test2: x < &0"
    else
      let ltm, t_tm = dest_comb (concl t_th) in
      let j_tm = rand (rand ltm) in
      let suc_j = eval_suc j_tm in
      let i_tm = rand (concl suc_j) in
      let mul_hi = float_mul_hi pp x_tm t_tm in
      let hi_tm = rand (concl mul_hi) in
      let th0 = INST[x_tm, x_var_real; j_tm, j_var_num;
		     t_tm, t_var_real; hi_tm, hi_var_real;
		     i_tm, i_var_num] float_pow_pos_suc_hi' in
	MY_PROVE_HYP x_ge0 (MY_PROVE_HYP t_th (MY_PROVE_HYP mul_hi (MY_PROVE_HYP suc_j th0)));;



let pp = 3;;
let x_tm = f2;;
let t_th = (RULE o REWRITE_RULE[SYM More_float.float2_eq; SYM More_float.float4_eq] o prove)
  (`&2 pow 2 <= &4`, REAL_ARITH_TAC);;

(* 10: 1.31 *)
test 10000 (float_pow_pos_suc_hi pp x_tm) t_th;;      
(* 10: 1.33 *)
test 10000 (test2 pp x_tm) t_th;;      




